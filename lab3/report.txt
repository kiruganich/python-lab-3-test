Lab 3 - Algorithmic Mini-Package - Report
=========================================

1. Description of Implemented Algorithms

1.1 Factorial and Fibonacci Functions
- factorial(n): Calculates n! using iterative approach with O(n) time complexity
- factorial_recursive(n): Calculates n! using recursive approach with O(n) time complexity
- fibo(n): Calculates the n-th Fibonacci number iteratively with O(n) time complexity
- fibo_recursive(n): Calculates the n-th Fibonacci number recursively with O(2^n) time complexity

1.2 Sorting Algorithms
- Bubble Sort: Simple comparison-based sorting with O(n^2) time complexity. It repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.
- Counting Sort: Non-comparison sorting algorithm that works by counting occurrences of each distinct element. Time complexity is O(n + k) where k is the range of input.
- Bucket Sort: Distribution sorting algorithm that works by distributing elements into several buckets, sorting each bucket individually (using a simpler sorting algorithm), and then concatenating the results. Time complexity is O(n + k) average case.

1.3 Data Structures
- Stack: Basic LIFO data structure with push, pop, peek operations and O(1) time complexity for all operations.
- MinStack: Stack that supports retrieving minimum element in O(1) time using an auxiliary stack to track minimums.

2. Benchmark Results

The following benchmark results were obtained by running the algorithms on different types of input arrays:

- Random (int): Array of 1000 random integers
- Nearly Sorted: Array of 1000 integers with 50 random swaps applied to a sorted array
- Many Duplicates: Array of 1000 integers with only 10 unique values
- Reverse Sorted: Array of 1000 integers in descending order
- Random (float): Array of 1000 random floats in [0, 1) range

Note: Specific timing results would be displayed when running the CLI script.

3. Comparative Efficiency Analysis

- Bubble Sort: Has O(n^2) time complexity and is generally the slowest algorithm for large datasets. However, it's simple to implement and has good space complexity O(1).
- Counting Sort: Very efficient for integers with limited range, with O(n+k) time complexity. However, it requires knowing the range of input values and uses additional space proportional to the range.
- Bucket Sort: Most efficient for uniformly distributed float data, with O(n) average case complexity. It performs poorly if the input is not uniformly distributed.

The choice of algorithm depends on the characteristics of the input data:
- For small datasets: Bubble sort is acceptable
- For integer data with limited range: Counting sort is optimal
- For uniformly distributed float data: Bucket sort is most efficient